name: ffl

defaults:
    - lidar_encoder: pointpillars
    - polygonization: asm_acm

encoder:
    type: UNetResNet101
    pretrained: true

    in_size: 512
    in_height: ${.in_size}
    in_width: ${.in_size}

    depth: 101
    num_filters: 32
    dropout_2d: 0.2
    is_deconv: False
    
    out_feature_size: 512
    out_feature_height: ${.out_feature_size}
    out_feature_width: ${.out_feature_size}
    out_feature_channels: 32

    compute_seg: True
    compute_crossfield: True

    seg:
        compute_interior: True
        compute_edge: False
        compute_vertex: False

lidar_encoder:
    # in theory, these are values in [m]. However, because I scale the LiDAR tile to match image coordinates, these are [m]*s, i.e. here s=224/56
    # in fact, one voxel is always 0.25m x 0.25m, so the standard voxel size is 2m x 2m
    in_voxel_size:
        x: 8
        y: 8

    max_num_points_per_voxel: 128 # this should be something around points_per_tile / num_voxels_per_tile, however, I find that half of that value is enough

    max_num_voxels: # (in_image_size / in_voxel_size)**2
        train: 4096
        test: 4096

    out_feature_width: ${..encoder.out_feature_width}
    out_feature_height: ${..encoder.out_feature_height}

    out_feature_channels: ${..encoder.out_feature_channels}


augmentations:
    - D4
    - Resize
    - ColorJitter
    - GaussNoise

loss:
  multi:
    epoch_thresholds: [0, 5, 10]  # From 0 to 5: gradually go from coefs[0] to coefs[1] for list coefs
    weights:
      seg: 10
      crossfield_align: 1
      crossfield_align90: 0.2
      crossfield_smooth: 0.005
      seg_interior_crossfield: [0, 0, 0.2]
      seg_edge_crossfield: [0, 0, 0.2]
      seg_edge_interior: [0, 0, 0.2]
  seg:
    bce_coef: 1.0
    dice_coef: 0.2
    use_freq: true # Frequency weights per pixel class, e.g. weight building interior higher
    use_dist: true  # Dist weights as in the original U-Net paper
    use_size: false  # Size weights increasing importance of smaller buildings
    w0: 50  # From original U-Net paper: distance weight to increase loss between objects
    sigma: 10  # From original U-Net paper: distance weight to increase loss between objects
    type: float # or bool


# training
batch_size: 32
start_epoch: 0
num_epochs: 300
milestone: 0
learning_rate: 1e-4
weight_decay: 0.0
gamma: 0.95


eval:

  patch_size: null
  patch_overlap: 200

  seg_threshold: 0.5

  # save_individual_outputs:
  #   image: false
  #   seg_gt: false
  #   seg: false
  #   seg_mask: false
  #   seg_opencities_mask: false
  #   seg_luxcarta: false
  #   crossfield: false
  #   uv_angles: false
  #   poly_shapefile: false
  #   poly_geojson: false
  #   poly_viz: false

  # save_aggregated_outputs:
  #   stats: false
  #   seg_coco: false
  #   poly_coco: false
